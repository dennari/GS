<!DOCTYPE html><html lang="en"><head><title>GrowthStories.Core/AggregateBase</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="GrowthStories.Core/AggregateBase"><meta name="groc-project-path" content="GrowthStories.Core/AggregateBase.cs"><meta name="groc-github-url" content="https://github.com/dennari/GS"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/dennari/GS/blob/master/GrowthStories.Core/AggregateBase.cs">GrowthStories.Core/AggregateBase.cs</a></div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper">ï»¿<span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> Growthstories.Core;
<span class="hljs-keyword">using</span> System.Reflection;
<span class="hljs-keyword">using</span> Microsoft.CSharp.RuntimeBinder;
<span class="hljs-keyword">using</span> CommonDomain;
<span class="hljs-keyword">using</span> CommonDomain.Core;
<span class="hljs-keyword">using</span> EventStore.Logging;

namespace Growthstories.Core
{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="aggregatebase-tstate-tcreate-">AggregateBase<TState, TCreate></h2>
<p>Aggregates handle commands (typically from the UI) and if the command is accepted (i.e. it can be obeyed at the current state)
raise/apply events in response. When an event is raised, it gets routed to a separate state object of type <a href="AggregateState.html">AggregateState</a>.
When an event is applied, aggregate&#39;s version is increased.
Aggregates can be queried for their uncommitted events, i.e. they are aware of their state related to persistence.
The class needs two generic parameters: the corresponding <code>State</code> class and the class of the initial <code>ICreateMessage</code>.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> AggregateBase&lt;TState, TCreate&gt; : AggregateBase, IGSAggregate
		<span class="hljs-keyword">where</span> TState : AggregateState, <span class="hljs-title">new</span>()
		<span class="hljs-keyword">where</span> TCreate : ICreateMessage
  {

		
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span>(IMessage command)
    {
      <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-string">"Can't handle Null"</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>no applicable overload was not found and we ended up calling ourself dynamically</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.applying)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(<span class="hljs-keyword">string</span>.Format(<span class="hljs-string">"Can't find handler for command {0}"</span>, command.GetType().ToString()));
      <span class="hljs-keyword">try</span>
      {
        Logger.Info(<span class="hljs-string">"Handle command {0}"</span>, command);
        <span class="hljs-keyword">this</span>.applying = <span class="hljs-keyword">true</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>the <code>dynamic</code> stuff here allows us to pass the handling to subclass&#39;s overloaded handler </p></div></div><div class="code"><div class="wrapper">        ((dynamic)<span class="hljs-keyword">this</span>).Handle((dynamic)command);
        <span class="hljs-keyword">this</span>.applying = <span class="hljs-keyword">false</span>;
      }
      <span class="hljs-keyword">catch</span> (RuntimeBinderException)
      {
        <span class="hljs-keyword">throw</span>;
      }


    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>every concrete aggregate has to handle deletion</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span>(IDeleteCommand cmd);



    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> HasUncommittedEvents
    {
      <span class="hljs-keyword">get</span>
      {
        <span class="hljs-keyword">return</span> ((IAggregate)<span class="hljs-keyword">this</span>).GetUncommittedEvents().Count &gt; <span class="hljs-number">0</span>;
      }
    }


    <span class="hljs-keyword">public</span> PullStreamType SyncStreamType { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">set</span>; }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> UIPersistable { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">set</span>; }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> applying = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">private</span> TState _state;
    <span class="hljs-keyword">private</span> IEventFactory _eventFactory;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ILog Logger = LogFactory.BuildLogger(<span class="hljs-keyword">typeof</span>(AggregateBase));

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ICollection&lt;IEvent&gt; UncommittedRemoteEvents = <span class="hljs-keyword">new</span> LinkedList&lt;IEvent&gt;();




    <span class="hljs-keyword">public</span> <span class="hljs-title">AggregateBase</span>()
    {
      <span class="hljs-keyword">this</span>.ApplyState(<span class="hljs-keyword">this</span>.InitializeState());
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetEventFactory</span>(IEventFactory factory)
    {
      <span class="hljs-keyword">this</span>._eventFactory = factory;
    }

    <span class="hljs-keyword">public</span> TState State
    {
      <span class="hljs-keyword">get</span>
      {
        <span class="hljs-keyword">return</span> _state;
      }
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>
      {
        _state = <span class="hljs-keyword">value</span>;
        _state.AggregateType = <span class="hljs-keyword">this</span>.GetType();
      }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Guid Id
    {
      <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> State.Id; }
      <span class="hljs-keyword">protected</span> <span class="hljs-keyword">set</span>
      {
      }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">int</span> Version
    {
      <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> State.Version; }
      <span class="hljs-keyword">protected</span> <span class="hljs-keyword">set</span>
      {
      }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ApplyState</span>(IMemento st)
    {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Let us only override an existing state with Version equal to 0</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.State != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.State.Version != <span class="hljs-number">0</span>)
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(<span class="hljs-string">"Can't override existing state"</span>);
      }

      TState state = (TState)st;
      SetupRoutes(state);
      <span class="hljs-keyword">this</span>.State = state;
    }

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> TState <span class="hljs-title">InitializeState</span>()
    {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TState();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetupRoutes</span>(IAppliesEvents state)
    {
      <span class="hljs-keyword">if</span> (state == <span class="hljs-keyword">null</span>)
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-string">"State cannot be null for the router"</span>);
      }
      RegisteredRoutes = <span class="hljs-keyword">new</span> ApplyEventRouter(state);

    }

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RaiseEvent</span>(IEvent Event)
    {

      Validate(Event);

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._eventFactory != <span class="hljs-keyword">null</span>)
        <span class="hljs-keyword">this</span>._eventFactory.Fill(Event, <span class="hljs-keyword">this</span>);
      Event.AggregateVersion = <span class="hljs-keyword">this</span>.Version + <span class="hljs-number">1</span>;

      <span class="hljs-keyword">var</span> sE = Event <span class="hljs-keyword">as</span> IAggregateEvent&lt;TState&gt;;
      <span class="hljs-keyword">if</span> (sE != <span class="hljs-keyword">null</span>)
      {
        sE.AggregateState = <span class="hljs-keyword">this</span>.State;
      }


      Logger.Info(<span class="hljs-string">"Raised event: {0}"</span>, Event.ToString());</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>calls ApplyEvent and increases Version</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">base</span>.RaiseEvent(Event); 

    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ApplyRemoteMessage</span>(IMessage e)
    {
      <span class="hljs-keyword">var</span> Event = e <span class="hljs-keyword">as</span> IEvent;
      <span class="hljs-keyword">if</span> (Event == <span class="hljs-keyword">null</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">"Only remote EVENTS accepted"</span>);

      Validate(Event);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>this is here ON PURPOSE</p></div></div><div class="code"><div class="wrapper">      Event.AggregateVersion = <span class="hljs-keyword">this</span>.Version + <span class="hljs-number">1</span>;

      <span class="hljs-keyword">var</span> sE = Event <span class="hljs-keyword">as</span> IAggregateEvent&lt;TState&gt;;
      <span class="hljs-keyword">if</span> (sE != <span class="hljs-keyword">null</span>)
      {
        sE.AggregateState = <span class="hljs-keyword">this</span>.State;
      }


      Logger.Info(<span class="hljs-string">"Raised REMOTE event: {0}"</span>, Event.ToString());
      <span class="hljs-keyword">base</span>.RaiseEvent(Event);
    }


    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Validate</span>(IEvent Event)
    {
      <span class="hljs-keyword">if</span> (Event == <span class="hljs-keyword">null</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-string">"Event"</span>);
    }


    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> IMemento <span class="hljs-title">GetSnapshot</span>()
    {
      <span class="hljs-keyword">return</span> State;
    }



    IAggregateState IGSAggregate.State
    {
      <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> State; }
    }




  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> IGSAggregate : IAggregate, IApplyState
  {
    <span class="hljs-keyword">void</span> SetEventFactory(IEventFactory factory);

    PullStreamType SyncStreamType { <span class="hljs-keyword">get</span>; }

    <span class="hljs-keyword">bool</span> UIPersistable { <span class="hljs-keyword">get</span>; }

    <span class="hljs-keyword">void</span> Handle(IMessage msg);

    <span class="hljs-keyword">void</span> Handle(IDeleteCommand cmd);

    IAggregateState State { <span class="hljs-keyword">get</span>; }

    <span class="hljs-keyword">void</span> ApplyRemoteMessage(IMessage Event);

    <span class="hljs-keyword">bool</span> HasUncommittedEvents { <span class="hljs-keyword">get</span>; }

  }


}</div></div></div></div></body></html>